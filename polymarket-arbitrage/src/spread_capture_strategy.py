[['BTC', 'ETH', 'SOL'], {}, ['Dict]:\n        "', '\n        Scan 15-minute crypto markets for spread opportunities\n        \n        Returns:\n            List of markets with good liquidity\n        "', '\n        opportunities = []\n        \n        try:\n            # Get 15-minute markets for target cryptos\n            for crypto in self.target_markets:\n                markets = await self.client.get_15min_markets(crypto)\n                \n                for market in markets:\n                    # Check liquidity\n                    if await self._has_good_liquidity(market):\n                        opportunities.append(market)\n                        \n        except Exception as e:\n            self.logger.error(f"Error scanning 15-minute markets: {e}', 'return opportunities\n    \n    async def _has_good_liquidity(self, market: Dict) -> bool:\n        "', '\n        Check if market has good liquidity for spread capture\n        \n        Args:\n            market: Market data dict\n            \n        Returns:\n            True if market has good liquidity\n        "', "\n        try:\n            orderbook = await self.client.get_orderbook(market['id'])\n            \n            # Check if YES price is in target range\n            best_yes = self._get_best_price(orderbook, 'YES', 'bid')\n            best_no = self._get_best_price(orderbook, 'NO', 'ask')\n            \n            if (self.yes_price_range[0] <= best_yes <= self.yes_price_range[1] and\n                self.no_price_range[0] <= best_no <= self.no_price_range[1]):\n                # Check if we can place both orders within position limit\n                total_cost = best_yes + best_no\n                if total_cost < 0.98:  # Ensure cost is under $1\n                    return True\n                    \n        except Exception as e:\n            self.logger.debug(f", "Liquidity check failed for {market.get('name', 'Unknown')}: {e}", 'return False\n    \n    def _get_best_price(self, orderbook: Dict, side: str, order_type: str) -> float:\n        "', '\n        Get best price from orderbook\n        \n        Args:\n            orderbook: Orderbook data\n            side: YES or NO\n            order_type: bid or ask\n            \n        Returns:\n            Best price\n        "', '\n        try:\n            orders = orderbook.get(f"{side.lower()}_{order_type}', [], 'if orders:\n                return float(orders[0][\'price\'])\n        except:\n            pass\n        return 0.0 if order_type == \'bid\' else 1.0\n    \n    async def execute_spread_capture(self, market: Dict) -> Optional[Dict]:\n        "', '\n        Execute spread capture trade\n        \n        Args:\n            market: Market to trade\n            \n        Returns:\n            Trade result or None\n        "', '\n        try:\n            market_id = market[\'id\']\n            market_name = market[\'name\']\n            \n            self.logger.info(f"Executing spread capture on {market_name}', 'Get current orderbook\n            orderbook = await self.client.get_orderbook(market_id)\n            \n            # Get best prices\n            yes_price = self._get_best_price(orderbook, \'YES\', \'bid\')\n            no_price = self._get_best_price(orderbook, \'NO\', \'ask\')\n            \n            # Validate prices are in range\n            if not (self.yes_price_range[0] <= yes_price <= self.yes_price_range[1]):\n                self.logger.debug(f"YES price {yes_price} not in range', 'return None\n                \n            if not (self.no_price_range[0] <= no_price <= self.no_price_range[1]):\n                self.logger.debug(f"NO price {no_price} not in range")\n                return None\n            \n            # Calculate position size (ensure total cost < $1)\n            total_cost = yes_price + no_price\n            if total_cost >= 0.98:\n                self.logger.debug(f"Total cost {total_cost} too high', "return None\n                \n            position_size = min(self.max_position_size, 1.0 / total_cost)\n            \n            # Place both orders simultaneously\n            yes_order = {\n                'market_id': market_id,\n                'side': 'BUY',\n                'price': yes_price,\n                'size': position_size\n            }\n            \n            no_order = {\n                'market_id': market_id,\n                'side': 'BUY',\n                'price': no_price,\n                'size': position_size\n            }\n            \n            # Execute both orders\n            if self.client.simulation_mode:\n                # Simulation mode - fake execution\n                self.logger.info(f", 'SIMULATED: Placed YES order at {yes_price}, NO order at {no_price}', 'success = True\n                expected_profit = (1.0 - total_cost) * position_size\n            else:\n                # Live mode - real execution\n                yes_result = await self.client.place_order(yes_order)\n                no_result = await self.client.place_order(no_order)\n                success = yes_result.get(\'success\', False) and no_result.get(\'success\', False)\n                expected_profit = (1.0 - total_cost) * position_size\n            \n            if success:\n                # Record trade\n                trade_record = {\n                    \'market_id\': market_id,\n                    \'market_name\': market_name,\n                    \'yes_price\': yes_price,\n                    \'no_price\': no_price,\n                    \'position_size\': position_size,\n                    \'total_cost\': total_cost,\n                    \'expected_profit\': expected_profit,\n                    \'timestamp\': datetime.now().isoformat(),\n                    \'simulated\': self.client.simulation_mode\n                }\n                \n                await self.database.record_spread_trade(trade_record)\n                \n                # Send notification\n                await self.notifier.send_message(\n                    "_CAPTURE Executed', 'f"Market: {market_name}\n"\n                    f', 'YES: {yes_price:.4f}, NO: {no_price:.4f}\n"\n                    f"Position: ${position_size:.2f}\n"\n                    f"Expected Profit: ${expected_profit:.2f}"\n                )\n                \n                self.logger.info(f"Spread capture executed on {market_name}")\n                return trade_record\n                \n        except Exception as e:\n            self.logger.error(f"Error executing spread capture: {e}")\n            await self.notifier.send_alert(\n                "_Capture Error', 'f', 'Failed on {market.get(\'name\', \'Unknown\')}: {str(e)}"\n            )\n            \n        return None\n    \n    async def run_strategy(self):\n        "', 'Run spread capture strategy continuously"', '\n        self.logger.info("Starting spread capture strategy', 'while True:\n            try:\n                # Check if it\'s time for 15-minute market cycle\n                current_minute = datetime.now().minute\n                if current_minute % 15 == 0:  # Run at :00, :15, :30, :45\n                    self.logger.info("Scanning 15-minute markets for spread opportunities")\n                    \n                    # Scan markets\n                    opportunities = await self.scan_15min_markets()\n                    \n                    if opportunities:\n                        self.logger.info(f"Found {len(opportunities)} spread opportunities")\n                        \n                        # Execute trades\n                        for market in opportunities:\n                            await self.execute_spread_capture(market)\n                            \n                            # Small delay between trades\n                            await asyncio.sleep(1)\n                    else:\n                        self.logger.info("No spread opportunities found")\n                \n                # Wait 1 minute before next check\n                await asyncio.sleep(60)\n                \n            except KeyboardInterrupt:\n                self.logger.info("Spread capture strategy stopped by user")\n                break\n            except Exception as e:\n                self.logger.error(f"Error in spread capture strategy: {e}")\n                await self.notifier.send_alert(\n                    "_Strategy Error', 'f"Spread capture error: {str(e)}', 'await asyncio.sleep(60)  # Wait longer after error\n\n# Add method to database class\nasync def record_spread_trade(self, trade_data: Dict):\n    "', 'Record spread capture trade in database"', '\n    try:\n        self.cursor.execute("', '\n            INSERT INTO spread_trades \n            (market_id, market_name, yes_price, no_price, position_size, \n             total_cost, expected_profit, timestamp, simulated)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n        "', ', (\n            trade_data[\'market_id\'],\n            trade_data[\'market_name\'],\n            trade_data[\'yes_price\'],\n            trade_data[\'no_price\'],\n            trade_data[\'position_size\'],\n            trade_data[\'total_cost\'],\n            trade_data[\'expected_profit\'],\n            trade_data[\'timestamp\'],\n            trade_data.get(\'simulated\', True)\n        ))\n        self.conn.commit()\n        self.logger.info("Spread trade recorded in database")\n    except Exception as e:\n        self.logger.error(f"Error recording spread trade: {e}']]